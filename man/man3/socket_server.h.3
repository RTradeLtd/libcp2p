.TH "/media/solidity/DATA/Code/RTradeLtd/libcp2p/include/network/socket_server.h" 3 "Sat Aug 8 2020" "libcp2p" \" -*- nroff -*-
.ad l
.nh
.SH NAME
/media/solidity/DATA/Code/RTradeLtd/libcp2p/include/network/socket_server.h \- used to create a tcp/udp socket server listening on multiaddrs  

.SH SYNOPSIS
.br
.PP
\fC#include 'crypto/ecdsa\&.h'\fP
.br
\fC#include 'crypto/key\&.h'\fP
.br
\fC#include 'crypto/peerutils\&.h'\fP
.br
\fC#include 'multiaddr/multiaddr\&.h'\fP
.br
\fC#include 'network/messages\&.h'\fP
.br
\fC#include 'network/socket_client\&.h'\fP
.br
\fC#include 'peerstore/peerstore\&.h'\fP
.br
\fC#include 'thirdparty/logger/logger\&.h'\fP
.br
\fC#include 'thirdparty/thread_pool/thread_pool\&.h'\fP
.br
\fC#include <arpa/inet\&.h>\fP
.br
\fC#include <netinet/in\&.h>\fP
.br
\fC#include <pthread\&.h>\fP
.br
\fC#include <stdbool\&.h>\fP
.br
\fC#include <sys/socket\&.h>\fP
.br
\fC#include <sys/time\&.h>\fP
.br
\fC#include <sys/types\&.h>\fP
.br

.SS "Data Structures"

.in +1c
.ti -1c
.RI "struct \fBsocket_server_config\fP"
.br
.ti -1c
.RI "struct \fBsocket_server\fP"
.br
.ti -1c
.RI "struct \fBclient_conn\fP"
.br
.RI "a structure containing a file descriptor and address information "
.ti -1c
.RI "struct \fBconn_handle_data\fP"
.br
.RI "struct containing arguments passed into pthread "
.in -1c
.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBMAX_ADDRS\fP   100"
.br
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef void() \fBthreadpool_task_func\fP(void *data)"
.br
.RI "defines a function signature that is used for submitting tasks to our thread pool "
.ti -1c
.RI "typedef struct \fBsocket_server_config\fP \fBsocket_server_config_t\fP"
.br
.RI "used for configuring a socket_server_t instance "
.ti -1c
.RI "typedef struct \fBsocket_server\fP \fBsocket_server_t\fP"
.br
.RI "a TCP/UDP socket server "
.ti -1c
.RI "typedef struct \fBclient_conn\fP \fBclient_conn_t\fP"
.br
.ti -1c
.RI "typedef struct \fBconn_handle_data\fP \fBconn_handle_data_t\fP"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "\fBsocket_server_t\fP * \fBnew_socket_server\fP (\fBthread_logger\fP *thl, \fBsocket_server_config_t\fP *config, \fBSOCKET_OPTS\fP sock_opts[], int num_opts)"
.br
.RI "used to create a TCP/UDP socket server ready to accept connections "
.ti -1c
.RI "\fBclient_conn_t\fP * \fBaccept_client_conn\fP (\fBsocket_server_t\fP *srv, int socket_num)"
.br
.RI "helper function for accepting client connections times out new attempts if they take 3 seconds or more "
.ti -1c
.RI "void \fBfree_socket_server\fP (\fBsocket_server_t\fP *srv)"
.br
.RI "terminates a server and frees up resources associated with it "
.ti -1c
.RI "void \fBstart_socket_server\fP (\fBsocket_server_t\fP *srv)"
.br
.RI "starts the socket server which processes new connections "
.ti -1c
.RI "void * \fBaccept_connections\fP (void *data)"
.br
.RI "dedicated function for accepting and handling new connections "
.ti -1c
.RI "void \fBsignal_shutdown\fP ()"
.br
.RI "used to signal that we should exit the main start_socket_server function "
.ti -1c
.RI "void \fBfree_socket_server_config\fP (\fBsocket_server_config_t\fP *config)"
.br
.RI "used to free up resources allocated for socket_server_config_t "
.ti -1c
.RI "\fBsocket_server_config_t\fP * \fBnew_socket_server_config\fP (int num_addrs)"
.br
.RI "used to initialize a socket_server_config_t object "
.ti -1c
.RI "void \fBhandle_inbound_rpc\fP (void *data)"
.br
.RI "handles receiving an rpc message from another peer "
.ti -1c
.RI "void \fBsetup_signal_shutdown\fP (int signals[], int num_signals)"
.br
.RI "used to specify which syscall signals should trigger shutdown process "
.ti -1c
.RI "bool \fBnegotiate_secure_connection\fP (\fBconn_handle_data_t\fP *data)"
.br
.RI "used to negotiate a secure connection with the current connection "
.ti -1c
.RI "bool \fBhandle_hello_protocol\fP (\fBconn_handle_data_t\fP *data, \fBmessage_t\fP *msg)"
.br
.RI "handles receiving a hello protocol message from another peer "
.ti -1c
.RI "int \fBsocket_server_send\fP (\fBsocket_server_t\fP *srv, \fBmulti_addr_t\fP *to_address, \fBmessage_t\fP *msg)"
.br
.RI "used for a server to send a message to another server "
.ti -1c
.RI "\fBmessage_hello_t\fP * \fBnew_server_message_hello_t\fP (\fBsocket_server_t\fP *srv)"
.br
.RI "helper function to return a message_hello_t using our server values "
.in -1c
.SH "Detailed Description"
.PP 
used to create a tcp/udp socket server listening on multiaddrs 


.PP
Definition in file \fBsocket_server\&.h\fP\&.
.SH "Macro Definition Documentation"
.PP 
.SS "#define MAX_ADDRS   100"

.PP
Definition at line 36 of file socket_server\&.h\&.
.SH "Typedef Documentation"
.PP 
.SS "typedef struct \fBclient_conn\fP \fBclient_conn_t\fP"

.SS "typedef struct \fBconn_handle_data\fP \fBconn_handle_data_t\fP"

.SS "\fBsocket_server_config_t\fP"

.PP
used for configuring a socket_server_t instance 
.PP
\fBTodo\fP
.RS 4
switch to multi_addresses 
.RE
.PP
.PP
once you have used the config and created a new server with \fBnew_socket_server()\fP you can free the socket config with free_socket_config 
.PP
\fBNote\fP
.RS 4
once you have used the config and created a new server with \fBnew_socket_server()\fP you can free the socket config with free_socket_config 
.RE
.PP

.SS "\fBsocket_server_t\fP"

.PP
a TCP/UDP socket server provides a thread pool can be used for handling new connections 
.PP
\fBTodo\fP
.RS 4
dont limit to two sockets (this will requiring using multiaddrs and an array of socket numbers) 
.RE
.PP

.SS "typedef void() threadpool_task_func(void *data)"

.PP
defines a function signature that is used for submitting tasks to our thread pool 
.PP
Definition at line 42 of file socket_server\&.h\&.
.SH "Function Documentation"
.PP 
.SS "\fBclient_conn_t\fP* accept_client_conn (\fBsocket_server_t\fP * srv, int socket_num)"

.PP
helper function for accepting client connections times out new attempts if they take 3 seconds or more 
.PP
\fBReturns\fP
.RS 4
Failure: NULL client conn failed 
.PP
Success: non-NULL populated \fBclient_conn\fP object 
.RE
.PP

.PP
Definition at line 325 of file socket_server\&.c\&.
.SS "void* accept_connections (void * data)"

.PP
dedicated function for accepting and handling new connections 
.PP
\fBNote\fP
.RS 4
processes new connections by launching them 
.RE
.PP

.SS "void free_socket_server (\fBsocket_server_t\fP * srv)"

.PP
terminates a server and frees up resources associated with it 
.PP
Definition at line 200 of file socket_server\&.c\&.
.SS "void free_socket_server_config (\fBsocket_server_config_t\fP * config)"

.PP
used to free up resources allocated for socket_server_config_t 
.PP
\fBParameters\fP
.RS 4
\fIconfig\fP an instance of socket_server_config_t initialized with new_socket_server_config 
.RE
.PP

.PP
Definition at line 355 of file socket_server\&.c\&.
.SS "bool handle_hello_protocol (\fBconn_handle_data_t\fP * data, \fBmessage_t\fP * msg)"

.PP
handles receiving a hello protocol message from another peer is responsible for exchanging identification information with a peer
.PP
and updating our peerstore with the appropriate information 
.PP
Definition at line 513 of file socket_server\&.c\&.
.SS "void handle_inbound_rpc (void * data)"

.PP
handles receiving an rpc message from another peer 
.PP
\fBNote\fP
.RS 4
if you send an inbound message of \fC5hello\fP you'll invoke a debug handler to print to stdout
.PP
if you send an inbound message of \fC5hello\fP you'll invoke a debug handler to print to stdout 
.RE
.PP
\fBWarning\fP
.RS 4
needs to check to see if the data we are getting is for a tcp or udp connection 
.PP
if a tcp connection we need to close the socket (as its the socket connecting to the client) 
.PP
if a udp connection we dont close the socket and simply free the resources 
.RE
.PP

.PP
Definition at line 391 of file socket_server\&.c\&.
.SS "bool negotiate_secure_connection (\fBconn_handle_data_t\fP * data)"

.PP
used to negotiate a secure connection with the current connection 
.PP
Definition at line 480 of file socket_server\&.c\&.
.SS "\fBmessage_hello_t\fP* new_server_message_hello_t (\fBsocket_server_t\fP * srv)"

.PP
helper function to return a message_hello_t using our server values 
.PP
Definition at line 634 of file socket_server\&.c\&.
.SS "\fBsocket_server_t\fP* new_socket_server (\fBthread_logger\fP * thl, \fBsocket_server_config_t\fP * config, \fBSOCKET_OPTS\fP sock_opts[], int num_opts)"

.PP
used to create a TCP/UDP socket server ready to accept connections 
.PP
\fBParameters\fP
.RS 4
\fIthl\fP an instance of a \fBthread_logger\fP 
.br
\fIconfig\fP the configuration settings used for the tcp/udp server 
.br
\fIsock_opts\fP an array of options to configure the sockets we open with 
.br
\fInum_opts\fP the number of socket options we are using, providing a number that does not match the actual number of options is undefined behavior 
.RE
.PP
\fBReturns\fP
.RS 4
Success: pointer to a socket_server_t instance 
.PP
Failure: NULL pointer
.RE
.PP
once you have used the config and created a new server with 
.PP
\fBNote\fP
.RS 4
once you have used the config and created a new server with 
.RE
.PP

.PP
Definition at line 57 of file socket_server\&.c\&.
.SS "\fBsocket_server_config_t\fP* new_socket_server_config (int num_addrs)"

.PP
used to initialize a socket_server_config_t object 
.PP
\fBParameters\fP
.RS 4
\fInum_addrs\fP the number of multi_addr_t objects the addrs member will contain 
.RE
.PP
\fBReturns\fP
.RS 4
Success: pointer to an initialized block of memory for socket_server_config_t 
.PP
Failure: NULL pointer 
.RE
.PP

.PP
Definition at line 370 of file socket_server\&.c\&.
.SS "void setup_signal_shutdown (int signals[], int num_signals)"

.PP
used to specify which syscall signals should trigger shutdown process 
.PP
Definition at line 471 of file socket_server\&.c\&.
.SS "void signal_shutdown ()"

.PP
used to signal that we should exit the main start_socket_server function 
.PP
\fBNote\fP
.RS 4
this is only useful if you launch start_socket_server in a thread 
.RE
.PP

.PP
Definition at line 314 of file socket_server\&.c\&.
.SS "int socket_server_send (\fBsocket_server_t\fP * srv, \fBmulti_addr_t\fP * to_address, \fBmessage_t\fP * msg)"

.PP
used for a server to send a message to another server this is a sort of 'bi-directional RPC method' whereby a server can send a
.PP
request to another server acting as a client, but enabling either us
.PP
or the peer to invoke RPC methods\&. Essentially it is like handle_inbound_rpc
.PP
except it is responsible for sending requests to a remote server, and any responses
.PP
from the server are ran through handle_inbound_rpc 
.PP
\fBReturns\fP
.RS 4
Success: 0 
.PP
Failure: -1 
.RE
.PP

.PP
Definition at line 585 of file socket_server\&.c\&.
.SS "void start_socket_server (\fBsocket_server_t\fP * srv)"

.PP
starts the socket server which processes new connections when a new connection is accepted (tcp) OR we can receive data on a udp socket, the given handle_conn_func is used to process that client connection 
.PP
\fBParameters\fP
.RS 4
\fIsrv\fP an instance of a socket_server_t that has been initialized through new_socket_server 
.br
\fIfn_tcp\fP 
.br
\fIfn_udp\fP when a new connection is accepted (tcp) OR we can receive data on a udp socket, the given handle_conn_func is used to process that client connection 
.br
\fIsrv\fP an instance of a socket_server_t that has been initialized through new_socket_server 
.RE
.PP

.PP
\fBTodo\fP
.RS 4
enable customizable timeout 
.RE
.PP
.PP
.IP "\(bu" 2
\fBNote\fP
.RS 4
copy the main socket list containing both tcp and udp sockets
.RE
.PP
iterate over all known sockets 
.PP
\fBNote\fP
.RS 4
this will likely search a few extra sockets, but the overhead should be neglibie
.RE
.PP

.PP

.PP
Definition at line 241 of file socket_server\&.c\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for libcp2p from the source code\&.
