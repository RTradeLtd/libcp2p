.TH "/media/solidity/DATA/Code/RTradeLtd/libcp2p/src/encoding/base32.c" 3 "Fri Jul 24 2020" "libcp2p" \" -*- nroff -*-
.ad l
.nh
.SH NAME
/media/solidity/DATA/Code/RTradeLtd/libcp2p/src/encoding/base32.c
.SH SYNOPSIS
.br
.PP
\fC#include <stddef\&.h>\fP
.br
\fC#include 'encoding/base32\&.h'\fP
.br
\fC#include <stdbool\&.h>\fP
.br
\fC#include <stdlib\&.h>\fP
.br
\fC#include <limits\&.h>\fP
.br
\fC#include <string\&.h>\fP
.br

.SS "Data Structures"

.in +1c
.ti -1c
.RI "struct \fBbase32_decode_context\fP"
.br
.in -1c
.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBBASE32_LENGTH\fP(inlen)   ((((inlen) + 4) / 5) * 8)"
.br
.ti -1c
.RI "#define \fBbase32_decode\fP(in,  inlen,  out,  outlen)   \fBbase32_decode_ctx\fP(NULL, in, inlen, out, outlen)"
.br
.ti -1c
.RI "#define \fBbase32_decode_alloc\fP(in,  inlen,  out,  outlen)   \fBbase32_decode_alloc_ctx\fP(NULL, in, inlen, out, outlen)"
.br
.ti -1c
.RI "#define \fBB32\fP(\fB_\fP)"
.br
.ti -1c
.RI "#define \fBuchar_in_range\fP(c)   ((c) <= 255)"
.br
.ti -1c
.RI "#define \fBreturn_false\fP"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "bool \fBisbase32\fP (char ch)"
.br
.ti -1c
.RI "void \fBbase32_encode\fP (const char *restrict in, size_t inlen, char *restrict out, size_t outlen)"
.br
.ti -1c
.RI "size_t \fBbase32_encode_alloc\fP (const char *in, size_t inlen, char **out)"
.br
.ti -1c
.RI "void \fBbase32_decode_ctx_init\fP (struct \fBbase32_decode_context\fP *ctx)"
.br
.ti -1c
.RI "bool \fBbase32_decode_ctx\fP (struct \fBbase32_decode_context\fP *ctx, const char *restrict in, size_t inlen, char *restrict out, size_t *outlen)"
.br
.ti -1c
.RI "bool \fBbase32_decode_alloc_ctx\fP (struct \fBbase32_decode_context\fP *ctx, const char *in, size_t inlen, char *out, size_t *outlen)"
.br
.ti -1c
.RI "static unsigned char \fBto_uchar\fP (char ch)"
.br
.ti -1c
.RI "static char * \fBget_8\fP (struct \fBbase32_decode_context\fP *ctx, char const *restrict *in, char const *restrict in_end, size_t *n_non_newline)"
.br
.ti -1c
.RI "static bool \fBdecode_8\fP (char const *restrict in, size_t inlen, char *restrict *outp, size_t *outleft)"
.br
.ti -1c
.RI "int \fBlibp2p_encoding_base32_encode\fP (const unsigned char *incoming, size_t incoming_length, unsigned char *results, size_t *results_length)"
.br
.RI "Encode in Base32 format\&. "
.ti -1c
.RI "size_t \fBlibp2p_encoding_base32_encode_size\fP (size_t incoming_length)"
.br
.RI "Calculate the size of the buffer necessary to encode\&. "
.ti -1c
.RI "int \fBlibp2p_encoding_base32_decode\fP (const unsigned char *incoming, size_t incoming_length, unsigned char *results, size_t *results_length)"
.br
.RI "Decode from Base16 format\&. "
.ti -1c
.RI "size_t \fBlibp2p_encoding_base32_decode_size\fP (size_t incoming_length)"
.br
.RI "Calculate the size of the buffer necessary to decode\&. "
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "static const signed char \fBb32\fP [0x100]"
.br
.in -1c
.SH "Macro Definition Documentation"
.PP 
.SS "#define B32(\fB_\fP)"

.PP
Definition at line 188 of file base32\&.c\&.
.SS "#define base32_decode(in, inlen, out, outlen)   \fBbase32_decode_ctx\fP(NULL, in, inlen, out, outlen)"

.PP
Definition at line 74 of file base32\&.c\&.
.SS "#define base32_decode_alloc(in, inlen, out, outlen)   \fBbase32_decode_alloc_ctx\fP(NULL, in, inlen, out, outlen)"

.PP
Definition at line 77 of file base32\&.c\&.
.SS "#define BASE32_LENGTH(inlen)   ((((inlen) + 4) / 5) * 8)"

.PP
Definition at line 50 of file base32\&.c\&.
.SS "#define return_false"
\fBValue:\fP
.PP
.nf
    do {              \
        *outp = out;  \
        return false; \
    } while (false)
.fi
.PP
Definition at line 334 of file base32\&.c\&.
.SS "#define uchar_in_range(c)   ((c) <= 255)"

.PP
Definition at line 279 of file base32\&.c\&.
.SH "Function Documentation"
.PP 
.SS "bool base32_decode_alloc_ctx (struct \fBbase32_decode_context\fP * ctx, const char * in, size_t inlen, char * out, size_t * outlen)"

.PP
Definition at line 519 of file base32\&.c\&.
.SS "bool base32_decode_ctx (struct \fBbase32_decode_context\fP * ctx, const char *restrict in, size_t inlen, char *restrict out, size_t * outlen)"

.PP
Definition at line 436 of file base32\&.c\&.
.SS "void base32_decode_ctx_init (struct \fBbase32_decode_context\fP * ctx)"

.PP
Definition at line 290 of file base32\&.c\&.
.SS "void base32_encode (const char *restrict in, size_t inlen, char *restrict out, size_t outlen)"

.PP
Definition at line 97 of file base32\&.c\&.
.SS "size_t base32_encode_alloc (const char * in, size_t inlen, char ** out)"

.PP
Definition at line 156 of file base32\&.c\&.
.SS "static bool decode_8 (char const *restrict in, size_t inlen, char *restrict * outp, size_t * outleft)\fC [static]\fP"

.PP
Definition at line 346 of file base32\&.c\&.
.SS "static char* get_8 (struct \fBbase32_decode_context\fP * ctx, char const *restrict * in, char const *restrict in_end, size_t * n_non_newline)\fC [static]\fP"

.PP
Definition at line 301 of file base32\&.c\&.
.SS "bool isbase32 (char ch)"

.PP
Definition at line 285 of file base32\&.c\&.
.SS "int libp2p_encoding_base32_decode (const unsigned char * incoming, size_t incoming_length, unsigned char * results, size_t * results_length)"

.PP
Decode from Base16 format\&. Decode from Base16 format 
.PP
\fBParameters\fP
.RS 4
\fIincoming\fP the incoming base16 encoded string 
.br
\fIincoming_length\fP the length of the incoming string (no need to include null) 
.br
\fIresults\fP where to put the results 
.br
\fIresults_length\fP the size of the buffer, and returns the actual length used 
.RE
.PP
\fBReturns\fP
.RS 4
true(1) on success 
.RE
.PP

.PP
Definition at line 586 of file base32\&.c\&.
.SS "size_t libp2p_encoding_base32_decode_size (size_t incoming_length)"

.PP
Calculate the size of the buffer necessary to decode\&. Calculate the size of the buffer necessary to decode 
.PP
\fBParameters\fP
.RS 4
\fIincoming_length\fP the length of the incoming value 
.RE
.PP
\fBReturns\fP
.RS 4
the size of the buffer necessary to hold the decoded bytes 
.RE
.PP

.PP
Definition at line 608 of file base32\&.c\&.
.SS "int libp2p_encoding_base32_encode (const unsigned char * incoming, size_t incoming_length, unsigned char * results, size_t * results_length)"

.PP
Encode in Base32 format\&. Public functions Encode in Base32 format 
.PP
\fBParameters\fP
.RS 4
\fIincoming\fP the incoming bytes 
.br
\fIincoming_length\fP the length of the incoming bytes 
.br
\fIresults\fP where to put the results 
.br
\fIresults_length\fP the size of the buffer, and returns the actual length used 
.RE
.PP
\fBReturns\fP
.RS 4
true(1) on success 
.RE
.PP

.PP
Definition at line 554 of file base32\&.c\&.
.SS "size_t libp2p_encoding_base32_encode_size (size_t incoming_length)"

.PP
Calculate the size of the buffer necessary to encode\&. Calculate the size of the buffer necessary to encode 
.PP
\fBParameters\fP
.RS 4
\fIincoming_length\fP the length of the incoming value 
.RE
.PP
\fBReturns\fP
.RS 4
the size of the buffer necessary to hold the encoded bytes 
.RE
.PP

.PP
Definition at line 570 of file base32\&.c\&.
.SS "static unsigned char to_uchar (char ch)\fC [static]\fP"

.PP
Definition at line 89 of file base32\&.c\&.
.SH "Variable Documentation"
.PP 
.SS "const signed char b32[0x100]\fC [static]\fP"

.PP
Definition at line 242 of file base32\&.c\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for libcp2p from the source code\&.
