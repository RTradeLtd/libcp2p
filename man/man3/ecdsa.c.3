.TH "/media/solidity/DATA/Code/RTradeLtd/libcp2p/src/crypto/ecdsa.c" 3 "Sat Aug 8 2020" "libcp2p" \" -*- nroff -*-
.ad l
.nh
.SH NAME
/media/solidity/DATA/Code/RTradeLtd/libcp2p/src/crypto/ecdsa.c
.SH SYNOPSIS
.br
.PP
\fC#include 'mbedtls/config\&.h'\fP
.br
\fC#include 'mbedtls/ecdsa\&.h'\fP
.br
\fC#include 'crypto/ecdsa\&.h'\fP
.br
\fC#include 'crypto/peerutils\&.h'\fP
.br
\fC#include 'crypto/util\&.h'\fP
.br
\fC#include 'mbedtls/asn1write\&.h'\fP
.br
\fC#include 'mbedtls/bignum\&.h'\fP
.br
\fC#include 'mbedtls/ctr_drbg\&.h'\fP
.br
\fC#include 'mbedtls/entropy\&.h'\fP
.br
\fC#include 'mbedtls/error\&.h'\fP
.br
\fC#include 'mbedtls/oid\&.h'\fP
.br
\fC#include 'mbedtls/pk\&.h'\fP
.br
\fC#include 'mbedtls/platform\&.h'\fP
.br
\fC#include 'mbedtls/x509\&.h'\fP
.br
\fC#include <errno\&.h>\fP
.br
\fC#include <fcntl\&.h>\fP
.br
\fC#include <pthread\&.h>\fP
.br
\fC#include <stdlib\&.h>\fP
.br
\fC#include <string\&.h>\fP
.br
\fC#include <sys/stat\&.h>\fP
.br
\fC#include <sys/types\&.h>\fP
.br
\fC#include <unistd\&.h>\fP
.br

.SS "Functions"

.in +1c
.ti -1c
.RI "int \fBlibp2p_crypto_ecdsa_free\fP (\fBecdsa_private_key_t\fP *pk)"
.br
.RI "frees up resources allocated for the private key "
.ti -1c
.RI "\fBpeer_id_t\fP * \fBlibp2p_crypto_ecdsa_keypair_peerid\fP (\fBecdsa_private_key_t\fP *pk)"
.br
.RI "returns a peer_id_t struct for the given private key "
.ti -1c
.RI "\fBpublic_key_t\fP * \fBlibp2p_crypto_ecdsa_keypair_public\fP (\fBecdsa_private_key_t\fP *pk)"
.br
.RI "returns the public key associated with the private key in PEM format "
.ti -1c
.RI "\fBecdsa_private_key_t\fP * \fBlibp2p_crypto_ecdsa_pem_to_private_key\fP (unsigned char *pem_input)"
.br
.RI "parses a PEM encoded private key and returns a struct for use "
.ti -1c
.RI "\fBecdsa_private_key_t\fP * \fBlibp2p_crypto_ecdsa_keypair_generation\fP (mbedtls_ecp_group_id curve)"
.br
.RI "used to generate an ECDSA keypair "
.ti -1c
.RI "int \fBlibp2p_crypto_ecdsa_private_key_save\fP (\fBecdsa_private_key_t\fP *pk, char *path)"
.br
.RI "used to save a private key at the given path "
.ti -1c
.RI "\fBecdsa_private_key_t\fP * \fBlibp2p_crypto_ecdsa_private_key_from_file\fP (char *path)"
.br
.RI "loads an ECDSA private key from a file containing a PEM key "
.ti -1c
.RI "unsigned char * \fBlibp2p_crypto_ecdsa_private_key_to_pem\fP (\fBecdsa_private_key_t\fP *pk)"
.br
.RI "takes a private key and returns its corresponding PEM format "
.in -1c
.SH "Function Documentation"
.PP 
.SS "int libp2p_crypto_ecdsa_free (\fBecdsa_private_key_t\fP * pk)"

.PP
frees up resources allocated for the private key 
.PP
Definition at line 50 of file ecdsa\&.c\&.
.SS "\fBecdsa_private_key_t\fP* libp2p_crypto_ecdsa_keypair_generation (mbedtls_ecp_group_id curve)"

.PP
used to generate an ECDSA keypair 
.PP
\fBReturns\fP
.RS 4
Success: pointer to an ecdsa_private_key_t instance 
.PP
NUULL pointer 
.RE
.PP

.IP "\(bu" 2
\fBTodo\fP
.RS 4
figure out if we need this 
.RE
.PP

.PP

.PP
Definition at line 183 of file ecdsa\&.c\&.
.SS "\fBpeer_id_t\fP* libp2p_crypto_ecdsa_keypair_peerid (\fBecdsa_private_key_t\fP * pk)"

.PP
returns a peer_id_t struct for the given private key this is useful for exchanging peer identifier information with
.PP
anyone who connects to our host 
.PP
\fBWarning\fP
.RS 4
caller must free returned pointer when no longer needed
.RE
.PP
to get the peerid we take a sha256 hash of the public key file in PEM format
.PP
we then generate a multihash of that sha256, and base58 encode it 
.PP
\fBTodo\fP
.RS 4
this currently relies on hard coded assumptions about hashing algorithm 
.PP
in the future this will change 
.RE
.PP
\fBParameters\fP
.RS 4
\fIpk\fP a loaded ecdsa_private_key_t instance 
.RE
.PP
\fBReturns\fP
.RS 4
Success: pointer to an instance of peer_id_t 
.PP
Failure: NULL pointer 
.RE
.PP

.PP
Definition at line 71 of file ecdsa\&.c\&.
.SS "\fBpublic_key_t\fP* libp2p_crypto_ecdsa_keypair_public (\fBecdsa_private_key_t\fP * pk)"

.PP
returns the public key associated with the private key in PEM format the returned struct is suitable for encoding into CBOR and sending to peers 
.PP
\fBWarning\fP
.RS 4
caller must free returned data when no longer 
.RE
.PP
\fBTodo\fP
.RS 4
this currently relies in usage of \fCstr\&.\&.\fP we should use \fCmem\&.\&.\&.\fP instead 
.RE
.PP
\fBReturns\fP
.RS 4
Success: an instance of public_key_t with the corresponding information 
.PP
Failure: NULL pointer 
.RE
.PP

.PP
Definition at line 108 of file ecdsa\&.c\&.
.SS "\fBecdsa_private_key_t\fP* libp2p_crypto_ecdsa_pem_to_private_key (unsigned char * pem_input)"

.PP
parses a PEM encoded private key and returns a struct for use the returned mbedtls_*_context in the struct are not suitable for concurrent use, please access through mutex locks 
.PP
\fBParameters\fP
.RS 4
\fIpem_input\fP the PEM encoded ECDSA private key 
.RE
.PP
\fBReturns\fP
.RS 4
an initialize and populated ecdsa_private_key_t 
.RE
.PP

.PP
Definition at line 145 of file ecdsa\&.c\&.
.SS "\fBecdsa_private_key_t\fP* libp2p_crypto_ecdsa_private_key_from_file (char * path)"

.PP
loads an ECDSA private key from a file containing a PEM key 
.PP
\fBParameters\fP
.RS 4
\fIpath\fP the path on disk to a PEM file containing an ECDSA private key 
.RE
.PP
\fBReturns\fP
.RS 4
Success: pointer to an instance of an ecdsa_private_key_t type 
.PP
Failure: NULL pointer 
.RE
.PP

.PP
Definition at line 275 of file ecdsa\&.c\&.
.SS "int libp2p_crypto_ecdsa_private_key_save (\fBecdsa_private_key_t\fP * pk, char * path)"

.PP
used to save a private key at the given path 
.PP
\fBParameters\fP
.RS 4
\fIpk\fP an instance of ecdsa_private_key_t 
.br
\fIpath\fP the location on disk to save file at 
.RE
.PP
\fBReturns\fP
.RS 4
Success: 0 
.PP
Failure: 1 
.RE
.PP

.PP
Definition at line 242 of file ecdsa\&.c\&.
.SS "unsigned char* libp2p_crypto_ecdsa_private_key_to_pem (\fBecdsa_private_key_t\fP * pk)"

.PP
takes a private key and returns its corresponding PEM format 
.PP
Definition at line 296 of file ecdsa\&.c\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for libcp2p from the source code\&.
