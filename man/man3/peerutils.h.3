.TH "/media/solidity/DATA/Code/RTradeLtd/libcp2p/include/crypto/peerutils.h" 3 "Thu Aug 6 2020" "libcp2p" \" -*- nroff -*-
.ad l
.nh
.SH NAME
/media/solidity/DATA/Code/RTradeLtd/libcp2p/include/crypto/peerutils.h \- provides utilities for managing peer identifiers  

.SH SYNOPSIS
.br
.PP
\fC#include 'crypto/sha256\&.h'\fP
.br
\fC#include 'multihash/hashes\&.h'\fP
.br
\fC#include 'multihash/multihash\&.h'\fP
.br
\fC#include 'stdio\&.h'\fP
.br
\fC#include 'string\&.h'\fP
.br

.SS "Data Structures"

.in +1c
.ti -1c
.RI "struct \fBpeer_id\fP"
.br
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef struct \fBpeer_id\fP \fBpeer_id_t\fP"
.br
.RI "contains the peer identifier (base encoded multihash of public key "
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "\fBpeer_id_t\fP * \fBlibp2p_new_peer_id_sha256\fP (unsigned char *\fBoutput\fP, size_t *output_len, unsigned char *\fBpublic_key\fP, size_t public_key_len)"
.br
.RI "generates a peerID for the public key using SHA256 as the hashing algorithm "
.ti -1c
.RI "\fBpeer_id_t\fP * \fBlibp2p_new_peer_id\fP (unsigned char *\fBoutput\fP, size_t *output_len, unsigned char *input_hash, size_t input_size)"
.br
.RI "constructs a peer identifier from the given public key "
.ti -1c
.RI "void \fBlibp2p_peer_id_free\fP (\fBpeer_id_t\fP *pid)"
.br
.RI "free up resources allocated for an instance of peer_id_t "
.in -1c
.SH "Detailed Description"
.PP 
provides utilities for managing peer identifiers 


.PP
Definition in file \fBpeerutils\&.h\fP\&.
.SH "Typedef Documentation"
.PP 
.SS "\fBpeer_id_t\fP"

.PP
contains the peer identifier (base encoded multihash of public key 
.PP
\fBNote\fP
.RS 4
not thread safe, should we add locking capabilities? 
.RE
.PP

.SH "Function Documentation"
.PP 
.SS "\fBpeer_id_t\fP* libp2p_new_peer_id (unsigned char * output, size_t * output_len, unsigned char * input_hash, size_t input_size)"

.PP
constructs a peer identifier from the given public key this is responsible for taking the hash of a public key
.PP
turning it into a multihash, and the base encoding it 
.PP
\fBNote\fP
.RS 4
is currently hard coded for the input hash being SHA256 
.PP
if you allocated memory for output param you can free it up after this function returns 
.PP
this is because we copy the data placed there into the returned struct 
.RE
.PP
\fBParameters\fP
.RS 4
\fIoutput\fP where to store the resulting peerID 
.br
\fIoutput_len\fP the max lenght of the output buffer, but will also be used to store size of buffer 
.br
\fIinput_hash\fP the input public key hash, usually sha256 
.br
\fIinput_size\fP the input size, usually 32 bytes 
.RE
.PP
\fBReturns\fP
.RS 4
Success: pointer to an instance of peer_id_t 
.PP
Failure: NULL pointer 
.RE
.PP

.PP
Definition at line 53 of file peerutils\&.c\&.
.SS "\fBpeer_id_t\fP* libp2p_new_peer_id_sha256 (unsigned char * output, size_t * output_len, unsigned char * public_key, size_t public_key_len)"

.PP
generates a peerID for the public key using SHA256 as the hashing algorithm is a wrapper around libp2p_new_peer_id that abstracts away hashing and memory allocs and stuff like that 
.PP
\fBParameters\fP
.RS 4
\fIoutput\fP where to store the resulting peerID 
.br
\fIoutput_len\fP the max lenght of the output buffer, but will also be used to store size of buffer 
.br
\fI\fBpublic_key\fP\fP the public key in PEM format to hash 
.br
\fIpublic_key_len\fP the length of the public key 
.RE
.PP
\fBReturns\fP
.RS 4
Success: pointer to an instance of peer_id_t 
.PP
Failure: NULL pointer 
.RE
.PP

.PP
Definition at line 21 of file peerutils\&.c\&.
.SS "void libp2p_peer_id_free (\fBpeer_id_t\fP * pid)"

.PP
free up resources allocated for an instance of peer_id_t 
.PP
Definition at line 95 of file peerutils\&.c\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for libcp2p from the source code\&.
